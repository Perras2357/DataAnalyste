Préparation Opérationnelle : Sauvegarde, Restauration et Automatisation

1) Objectif : 
 
 Mettre en place une stratégie de sauvegarde et de restauration robuste 
 Utilisation de la stratégie de sauvegarde logique quotidiennes avec pg_dump et rotation 
 Création de compte de services sécurisé pour les tâches ETL et d' Automatisation 
 
 2) Prérequis : Conf réseau et accès 
 Le but est de permettre à l'hôte (proxmox) de se connecter à la dase de données postgresql à l'intérieur du conteneur LXC. 
 
 
 Sur le conteneur : 
 
 
 Permettre la connexion réseau :
Modifier /etc/postgresql/XX/main/postgresql.conf accorder l'accès par l'adresse ip 
dont fait parti l'hôte (sous-réseau).
 
 
 Autoriser l'hôte à utiliser l'utilisateur de sauvegarde pour se connecter via modification /etc/postgresql/XX/main/pg_hba.conf . Ref : Conception du Modèle de Base de Données et d'Accès Utilisateur 
 # TYPE DATABASE USER ADDRESS METHOD
host all backup_user 192.168.1.1/32 md5
 
 
 
 Création de l'utilisateur de sauvegarde : 
 -- se connecter à psql en tant que superutilisateur
 CREATE ROLE backup_user WITH LOGIN PASSWORD 'un_mot_de_passe_solide';

 -- donner les droits de lecture sur les bases à sauvegarder
 GRANT CONNECT ON DATABASE n8n_db TO backup_user;

 GRANT SELECT ON ALL TABLES IN SCHEMA public TO backup_user;

 -- (Répétez pour les autres bases/schémas si nécessaire)
 
 NB : Ne pas oublier de rédémarrer posgresql pour appliquer les modifications 
 
 
 
 
 Config hôte : 
 
 
 Installer le client postgresql sur l'hôte 
 apt update
apt install postgresql-client
 
 
 
 Création du fichier de mot de passe pour le concerver hors script de sauvegarde : 
 nano ~/.pgpass
 
 
 
 Ajouter la ligne suivante : IP_DU_LXC:5432:*:backup_user:un_mot_de_passe_solide puis sécuriser le tout avec : droit de lecture et écriture du propriétaire 
 chmod 600 ~/.pgpass
 
 
 
 
 
 Script de sauvegarde shell : 
 
 
 On suppose que le disque de sauvegarde hdd1 est monté dans /mnt/ 
 
 
 Créer le script dans /root/scripts/pg_backup.sh 
 #!/bin/bash
#
# Script de sauvegarde PostgreSQL logique avec rotation GFS (Grandfather-Father-Son)
#

set -o pipefail # Assure que l'échec d'une commande dans un pipe fait échouer tout le pipe

# --- 1. CONFIGURATION (À MODIFIER) ---

# Répertoire de base pour TOUTES les sauvegardes (sur l'hôte Proxmox)
# Le script créera 'daily', 'weekly', 'monthly' à l'intérieur.
BACKUP_BASE_DIR="/mnt/hdd1/postgresqlBackup"

# Détails de connexion à PostgreSQL (dans l'LXC)
PGHOST="192.168.1.123" # <-- Mettez l'IP de votre conteneur LXC
PGPORT="5432"
PGUSER="backup_user" # L'utilisateur créé lors des prérequis

# Liste des bases de données à sauvegarder (séparées par un espace)
DATABASES="bookstack_db autre_db"

# Politique de rétention (nombre de copies à garder)
KEEP_DAILY=7
KEEP_WEEKLY=4
KEEP_MONTHLY=12

# Fichier de log
LOG_FILE="$BACKUP_BASE_DIR/backup.log"

# --- 2. GESTION DES NOTIFICATIONS D'ERREUR ---
# (Optionnel : décommentez et configurez si vous avez un service mail comme postfix ou msmtp)
# ADMIN_EMAIL="admin@example.com"
#
# notify_failure() {
# echo "ERREUR : La sauvegarde de $1 a échoué. Consultez $LOG_FILE pour les détails."
# # echo "Sujet: ÉCHEC Sauvegarde PostgreSQL ($1)" | mail -s "ÉCHEC Sauvegarde PG" "$ADMIN_EMAIL"
# }

# --- 3. VARIABLES ET RÉPERTOIRES ---

# Création des sous-répertoires de rotation
DAILY_DIR="$BACKUP_BASE_DIR/daily"
WEEKLY_DIR="$BACKUP_BASE_DIR/weekly"
MONTHLY_DIR="$BACKUP_BASE_DIR/monthly"

mkdir -p "$DAILY_DIR"
mkdir -p "$WEEKLY_DIR"
mkdir -p "$MONTHLY_DIR"

# Horodatage
DATE_TAG=$(date +"%Y%m%d-%H%M")
DAY_OF_WEEK=$(date +"%u") # 1 (Lundi) à 7 (Dimanche)
DAY_OF_MONTH=$(date +"%d") # 01 à 31

# Redirection de la sortie vers le fichier de log
exec &> >(tee -a "$LOG_FILE")

echo "-----------------------------------------------"
echo "Début du script de sauvegarde PG : $(date)"
echo "-----------------------------------------------"

# --- 4. BOUCLE DE SAUVEGARDE (pg_dump) ---

# Tableau pour suivre les fichiers créés avec succès
successful_files=()

for DB_NAME in $DATABASES; do

 FILENAME="$DB_NAME-$DATE_TAG.dump"
 FILEPATH="$DAILY_DIR/$FILENAME"

 echo "Sauvegarde de la base '$DB_NAME' vers '$FILEPATH'..."

 # Exécution de pg_dump
 # -Fc : Format "custom" (compressé, requis pour la restauration granulaire)
 # Le mot de passe est lu depuis ~/.pgpass
 pg_dump -U "$PGUSER" -h "$PGHOST" -p "$PGPORT" -Fc -f "$FILEPATH" "$DB_NAME"

 # Gestion des erreurs
 if [ $? -eq 0 ]; then
 echo "Succès : Sauvegarde de '$DB_NAME' terminée."
 successful_files+=("$FILENAME")
 else
 echo "ERREUR : La sauvegarde de '$DB_NAME' a échoué (code $?)."
 # notify_failure "$DB_NAME"
 rm -f "$FILEPATH" # Supprime le fichier partiel en cas d'échec
 fi
done

echo "Toutes les sauvegardes pg_dump sont terminées."

# --- 5. LOGIQUE DE ROTATION (GFS) ---

echo "Début de la rotation GFS..."

# S'il n'y a pas eu de nouvelles sauvegardes, on ne fait pas de rotation
if [ ${#successful_files[@]} -eq 0 ]; then
 echo "Aucune nouvelle sauvegarde réussie. Rotation annulée."
 exit 1
fi

# Copie pour rétention MENSUELLE (ex: le 1er du mois)
if [ "$DAY_OF_MONTH" -eq "01" ]; then
 echo "Promotion en sauvegarde MENSUELLE (jour 01)..."
 for file in "${successful_files[@]}"; do
 ln "$DAILY_DIR/$file" "$MONTHLY_DIR/"
 done
fi

# Copie pour rétention HEBDOMADAIRE (ex: le Dimanche, jour 7)
if [ "$DAY_OF_WEEK" -eq "7" ]; then
 echo "Promotion en sauvegarde HEBDOMADAIRE (Dimanche)..."
 for file in "${successful_files[@]}"; do
 ln "$DAILY_DIR/$file" "$WEEKLY_DIR/"
 done
fi

# --- 6. NETTOYAGE DES ANCIENNES SAUVEGARDES ---

# Nettoyage Daily: Garde les $KEEP_DAILY plus récents
echo "Nettoyage des sauvegardes Daily (garde $KEEP_DAILY)..."
(cd "$DAILY_DIR" && ls -t1 *.dump 2>/dev/null | tail -n +$((KEEP_DAILY + 1)) | xargs -r rm -v)
# Explication :
# ls -t1 : liste par date (plus récent en premier)
# tail -n +X : Affiche à partir de la X-ième ligne (ex: +8 pour garder les 7 premiers)
# xargs -r rm : Supprime les fichiers (le -r évite l'erreur si tail ne renvoie rien)

# Nettoyage Weekly: Garde les $KEEP_WEEKLY plus récents
echo "Nettoyage des sauvegardes Weekly (garde $KEEP_WEEKLY)..."
(cd "$WEEKLY_DIR" && ls -t1 *.dump 2>/dev/null | tail -n +$((KEEP_WEEKLY + 1)) | xargs -r rm -v)

# Nettoyage Monthly: Garde les $KEEP_MONTHLY plus récents
echo "Nettoyage des sauvegardes Monthly (garde $KEEP_MONTHLY)..."
(cd "$MONTHLY_DIR" && ls -t1 *.dump 2>/dev/null | tail -n +$((KEEP_MONTHLY + 1)) | xargs -r rm -v)

echo "-----------------------------------------------"
echo "Script de sauvegarde terminé : $(date)"
echo "-----------------------------------------------"
echo ""
 
 
 
 
 
 Explication du Script : 
 
 Configuration : Toutes les variables à modifier sont en haut du script. 
 Format -Fc : C'est le format "custom" de Postgres. Il est déjà compressé et permet une restauration granulaire (une seule table, par exemple) avec pg_restore. 
 Gestion des erreurs : Le script vérifie le code de sortie ($?) de pg_dump. S'il échoue, il le note dans le log et ne procède pas à la rotation de ce fichier. 
 Rotation (GFS) :
 
 Chaque jour, une nouvelle sauvegarde est placée dans /daily. 
 Si c'est le jour 1 du mois, un lien physique (ln) est créé dans /monthly. 
 Si c'est un dimanche, un lien physique est créé dans /weekly. L'utilisation de ln (lien physique) est cruciale : cela ne duplique pas les données sur le disque. Le fichier n'occupe de la place qu'une seule fois, même s'il apparaît dans les trois dossiers. L'espace disque ne sera libéré que lorsque la dernière référence (daily, weekly ou monthly) à ce fichier sera supprimée par le script de nettoyage. 
 Nettoyage : La méthode ls -t | tail -n +X | xargs rm est la plus sûre pour garantir que vous gardez "exactement N fichiers", peu importe s'il y a eu des échecs de sauvegarde certains jours. 
 
 
 
 
 
 Mise en Place (Cron) : 
 
 
 Rendre le script exécutable : 
 chmod +x /root/scripts/pg_backup.sh
 
 
 
 Test manuelle pour vérifier les permissions et la connexion : 
 /root/scripts/pg_backup.sh
 
 NB : Vérifiez ensuite le contenu de /mnt/hdd1/postgresqlBackup/daily/ et le log /mnt/hdd1/postgresqlBackup/backup.log. 
 
 
 Planifier la tâche Cron : editer le crontab de l'utilisateur root : 
 crontab -e
 
 
 
 Ajouter cette ligne pour l'exécuter tous les jours à 6h30 du matin 
 # Exécuter la sauvegarde PostgreSQL logique tous les jours à 6h30
30 6 * * * /root/scripts/pg_backup.sh 
 
 
 
 
 
 Cette configuration répond précisément à toutes les exigences : 
 sauvegarde logique avec pg_dump -Fc, horodatage, gestion des erreurs basique, 
 et rotation GFS (7 quotidiens, 4 hebdomadaires, 12 mensuels) sur votre disque hdd1.